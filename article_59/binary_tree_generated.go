// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package main

import "fmt"

type Float32Node struct {
	Value float32
	Left  *Float32Node
	Right *Float32Node
}

type Float32BinaryTree struct {
	Root *Float32Node
}

func (bt *Float32BinaryTree) Insert(value float32) {
	node := &Float32Node{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertFloat32Node(bt.Root, node)
	}
}

func insertFloat32Node(node, newNode *Float32Node) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertFloat32Node(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertFloat32Node(node.Right, newNode)
		}
	}
}

func printFloat32Tree(node *Float32Node, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printFloat32Tree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printFloat32Tree(node.Right, level)
	}
}

/*
func main() {
var bt Float32BinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type Float64Node struct {
	Value float64
	Left  *Float64Node
	Right *Float64Node
}

type Float64BinaryTree struct {
	Root *Float64Node
}

func (bt *Float64BinaryTree) Insert(value float64) {
	node := &Float64Node{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertFloat64Node(bt.Root, node)
	}
}

func insertFloat64Node(node, newNode *Float64Node) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertFloat64Node(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertFloat64Node(node.Right, newNode)
		}
	}
}

func printFloat64Tree(node *Float64Node, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printFloat64Tree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printFloat64Tree(node.Right, level)
	}
}

/*
func main() {
var bt Float64BinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type IntNode struct {
	Value int
	Left  *IntNode
	Right *IntNode
}

type IntBinaryTree struct {
	Root *IntNode
}

func (bt *IntBinaryTree) Insert(value int) {
	node := &IntNode{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertIntNode(bt.Root, node)
	}
}

func insertIntNode(node, newNode *IntNode) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertIntNode(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertIntNode(node.Right, newNode)
		}
	}
}

func printIntTree(node *IntNode, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printIntTree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printIntTree(node.Right, level)
	}
}

/*
func main() {
var bt IntBinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type Int16Node struct {
	Value int16
	Left  *Int16Node
	Right *Int16Node
}

type Int16BinaryTree struct {
	Root *Int16Node
}

func (bt *Int16BinaryTree) Insert(value int16) {
	node := &Int16Node{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertInt16Node(bt.Root, node)
	}
}

func insertInt16Node(node, newNode *Int16Node) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertInt16Node(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertInt16Node(node.Right, newNode)
		}
	}
}

func printInt16Tree(node *Int16Node, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printInt16Tree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printInt16Tree(node.Right, level)
	}
}

/*
func main() {
var bt Int16BinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type Int32Node struct {
	Value int32
	Left  *Int32Node
	Right *Int32Node
}

type Int32BinaryTree struct {
	Root *Int32Node
}

func (bt *Int32BinaryTree) Insert(value int32) {
	node := &Int32Node{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertInt32Node(bt.Root, node)
	}
}

func insertInt32Node(node, newNode *Int32Node) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertInt32Node(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertInt32Node(node.Right, newNode)
		}
	}
}

func printInt32Tree(node *Int32Node, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printInt32Tree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printInt32Tree(node.Right, level)
	}
}

/*
func main() {
var bt Int32BinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type Int64Node struct {
	Value int64
	Left  *Int64Node
	Right *Int64Node
}

type Int64BinaryTree struct {
	Root *Int64Node
}

func (bt *Int64BinaryTree) Insert(value int64) {
	node := &Int64Node{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertInt64Node(bt.Root, node)
	}
}

func insertInt64Node(node, newNode *Int64Node) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertInt64Node(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertInt64Node(node.Right, newNode)
		}
	}
}

func printInt64Tree(node *Int64Node, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printInt64Tree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printInt64Tree(node.Right, level)
	}
}

/*
func main() {
var bt Int64BinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type Int8Node struct {
	Value int8
	Left  *Int8Node
	Right *Int8Node
}

type Int8BinaryTree struct {
	Root *Int8Node
}

func (bt *Int8BinaryTree) Insert(value int8) {
	node := &Int8Node{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertInt8Node(bt.Root, node)
	}
}

func insertInt8Node(node, newNode *Int8Node) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertInt8Node(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertInt8Node(node.Right, newNode)
		}
	}
}

func printInt8Tree(node *Int8Node, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printInt8Tree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printInt8Tree(node.Right, level)
	}
}

/*
func main() {
var bt Int8BinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type UintNode struct {
	Value uint
	Left  *UintNode
	Right *UintNode
}

type UintBinaryTree struct {
	Root *UintNode
}

func (bt *UintBinaryTree) Insert(value uint) {
	node := &UintNode{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertUintNode(bt.Root, node)
	}
}

func insertUintNode(node, newNode *UintNode) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertUintNode(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertUintNode(node.Right, newNode)
		}
	}
}

func printUintTree(node *UintNode, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printUintTree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printUintTree(node.Right, level)
	}
}

/*
func main() {
var bt UintBinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type Uint16Node struct {
	Value uint16
	Left  *Uint16Node
	Right *Uint16Node
}

type Uint16BinaryTree struct {
	Root *Uint16Node
}

func (bt *Uint16BinaryTree) Insert(value uint16) {
	node := &Uint16Node{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertUint16Node(bt.Root, node)
	}
}

func insertUint16Node(node, newNode *Uint16Node) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertUint16Node(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertUint16Node(node.Right, newNode)
		}
	}
}

func printUint16Tree(node *Uint16Node, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printUint16Tree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printUint16Tree(node.Right, level)
	}
}

/*
func main() {
var bt Uint16BinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type Uint32Node struct {
	Value uint32
	Left  *Uint32Node
	Right *Uint32Node
}

type Uint32BinaryTree struct {
	Root *Uint32Node
}

func (bt *Uint32BinaryTree) Insert(value uint32) {
	node := &Uint32Node{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertUint32Node(bt.Root, node)
	}
}

func insertUint32Node(node, newNode *Uint32Node) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertUint32Node(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertUint32Node(node.Right, newNode)
		}
	}
}

func printUint32Tree(node *Uint32Node, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printUint32Tree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printUint32Tree(node.Right, level)
	}
}

/*
func main() {
var bt Uint32BinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type Uint64Node struct {
	Value uint64
	Left  *Uint64Node
	Right *Uint64Node
}

type Uint64BinaryTree struct {
	Root *Uint64Node
}

func (bt *Uint64BinaryTree) Insert(value uint64) {
	node := &Uint64Node{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertUint64Node(bt.Root, node)
	}
}

func insertUint64Node(node, newNode *Uint64Node) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertUint64Node(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertUint64Node(node.Right, newNode)
		}
	}
}

func printUint64Tree(node *Uint64Node, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printUint64Tree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printUint64Tree(node.Right, level)
	}
}

/*
func main() {
var bt Uint64BinaryTree ;
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printTree(bt.Root, 0)
}
*/

type Uint8Node struct {
	Value uint8
	Left  *Uint8Node
	Right *Uint8Node
}

type Uint8BinaryTree struct {
	Root *Uint8Node
}

func (bt *Uint8BinaryTree) Insert(value uint8) {
	node := &Uint8Node{value, nil, nil}
	if bt.Root == nil {
		bt.Root = node
	} else {
		insertUint8Node(bt.Root, node)
	}
}

func insertUint8Node(node, newNode *Uint8Node) {
	if newNode.Value < node.Value {
		if node.Left == nil {
			node.Left = newNode
		} else {
			insertUint8Node(node.Left, newNode)
		}
	} else {
		if node.Right == nil {
			node.Right = newNode
		} else {
			insertUint8Node(node.Right, newNode)
		}
	}
}

func printUint8Tree(node *Uint8Node, level int) {
	if node != nil {
		format := ""
		for i := 0; i < level; i++ {
			format += "       "
		}
		format += "---[ "
		level++
		printUint8Tree(node.Left, level)
		fmt.Printf(format+"%v\n", node.Value)
		printUint8Tree(node.Right, level)
	}
}

func main() {
	var bt Uint8BinaryTree
	bt.Insert(8)

	bt.Insert(3)
	bt.Insert(11)

	bt.Insert(1)
	bt.Insert(0)
	bt.Insert(2)

	bt.Insert(5)
	bt.Insert(4)
	bt.Insert(6)

	bt.Insert(9)
	bt.Insert(8)
	bt.Insert(10)

	bt.Insert(13)
	bt.Insert(12)
	bt.Insert(14)

	printUint8Tree(bt.Root, 0)
}
